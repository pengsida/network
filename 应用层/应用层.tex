% !TeX spellcheck = en_US
%% 字体：方正静蕾简体
%%		 方正粗宋
\documentclass[a4paper,left=2.5cm,right=2.5cm,11pt]{article}

\usepackage[utf8]{inputenc}
\usepackage{fontspec}
\usepackage{cite}
\usepackage{xeCJK}
\usepackage{indentfirst}
\usepackage{titlesec}
\usepackage{longtable}
\usepackage{graphicx}
\usepackage{float}
\usepackage{rotating}
\usepackage{subfigure}
\usepackage{tabu}
\usepackage{amsmath}
\usepackage{setspace}
\usepackage{amsfonts}
\usepackage{appendix}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry}
\setcounter{secnumdepth}{4}
\usepackage{mhchem}
\usepackage{multirow}
\usepackage{extarrows}
\usepackage{hyperref}
\titleformat*{\section}{\LARGE}
\renewcommand\refname{参考文献}
\renewcommand{\abstractname}{\sihao \cjkfzcs 摘{  }要}
%\titleformat{\chapter}{\centering\bfseries\huge\wryh}{}{0.7em}{}{}
%\titleformat{\section}{\LARGE\bf}{\thesection}{1em}{}{}
\titleformat{\subsection}{\Large\bfseries}{\thesubsection}{1em}{}{}
\titleformat{\subsubsection}{\large\bfseries}{\thesubsubsection}{1em}{}{}
\renewcommand{\contentsname}{{\cjkfzcs \centerline{目{  } 录}}}
\setCJKfamilyfont{cjkhwxk}{STXingkai}
\setCJKfamilyfont{cjkfzcs}{STSongti-SC-Regular}
% \setCJKfamilyfont{cjkhwxk}{华文行楷}
% \setCJKfamilyfont{cjkfzcs}{方正粗宋简体}
\newcommand*{\cjkfzcs}{\CJKfamily{cjkfzcs}}
\newcommand*{\cjkhwxk}{\CJKfamily{cjkhwxk}}
\newfontfamily\wryh{Microsoft YaHei}
\newfontfamily\hwzs{STZhongsong}
\newfontfamily\hwst{STSong}
\newfontfamily\hwfs{STFangsong}
\newfontfamily\jljt{MicrosoftYaHei}
\newfontfamily\hwxk{STXingkai}
% \newfontfamily\hwzs{华文中宋}
% \newfontfamily\hwst{华文宋体}
% \newfontfamily\hwfs{华文仿宋}
% \newfontfamily\jljt{方正静蕾简体}
% \newfontfamily\hwxk{华文行楷}
\newcommand{\verylarge}{\fontsize{60pt}{\baselineskip}\selectfont}  
\newcommand{\chuhao}{\fontsize{44.9pt}{\baselineskip}\selectfont}  
\newcommand{\xiaochu}{\fontsize{38.5pt}{\baselineskip}\selectfont}  
\newcommand{\yihao}{\fontsize{27.8pt}{\baselineskip}\selectfont}  
\newcommand{\xiaoyi}{\fontsize{25.7pt}{\baselineskip}\selectfont}  
\newcommand{\erhao}{\fontsize{23.5pt}{\baselineskip}\selectfont}  
\newcommand{\xiaoerhao}{\fontsize{19.3pt}{\baselineskip}\selectfont} 
\newcommand{\sihao}{\fontsize{14pt}{\baselineskip}\selectfont}      % 字号设置  
\newcommand{\xiaosihao}{\fontsize{12pt}{\baselineskip}\selectfont}  % 字号设置  
\newcommand{\wuhao}{\fontsize{10.5pt}{\baselineskip}\selectfont}    % 字号设置  
\newcommand{\xiaowuhao}{\fontsize{9pt}{\baselineskip}\selectfont}   % 字号设置  
\newcommand{\liuhao}{\fontsize{7.875pt}{\baselineskip}\selectfont}  % 字号设置  
\newcommand{\qihao}{\fontsize{5.25pt}{\baselineskip}\selectfont}    % 字号设置 

\usepackage{diagbox}
\usepackage{multirow}
\boldmath
\XeTeXlinebreaklocale "zh"
\XeTeXlinebreakskip = 0pt plus 1pt minus 0.1pt
\definecolor{cred}{rgb}{0.8,0.8,0.8}
\definecolor{cgreen}{rgb}{0,0.3,0}
\definecolor{cpurple}{rgb}{0.5,0,0.35}
\definecolor{cdocblue}{rgb}{0,0,0.3}
\definecolor{cdark}{rgb}{0.95,1.0,1.0}
\lstset{
	language=bash,
	numbers=left,
	numberstyle=\tiny\color{black},
	showspaces=false,
	showstringspaces=false,
	basicstyle=\scriptsize,
	keywordstyle=\color{purple},
	commentstyle=\itshape\color{cgreen},
	stringstyle=\color{blue},
	frame=lines,
	% escapeinside=``,
	extendedchars=true, 
	xleftmargin=1em,
	xrightmargin=1em, 
	backgroundcolor=\color{cred},
	aboveskip=1em,
	breaklines=true,
	tabsize=4
} 

\newfontfamily{\consolas}{Consolas}
\newfontfamily{\monaco}{Monaco}
\setmonofont[Mapping={}]{Consolas}	%英文引号之类的正常显示，相当于设置英文字体
\setsansfont{Consolas} %设置英文字体 Monaco, Consolas,  Fantasque Sans Mono
\setmainfont{Times New Roman}

\setCJKmainfont{华文中宋}


\newcommand{\fic}[1]{\begin{figure}[H]
		\center
		\includegraphics[width=0.8\textwidth]{#1}
	\end{figure}}
	
\newcommand{\sizedfic}[2]{\begin{figure}[H]
		\center
		\includegraphics[width=#1\textwidth]{#2}
	\end{figure}}

\newcommand{\codefile}[1]{\lstinputlisting{#1}}

\newcommand{\interval}{\vspace{0.5em}}

% 改变段间隔
\setlength{\parskip}{0.2em}
\linespread{1.1}

\usepackage{lastpage}
\usepackage{fancyhdr}
\pagestyle{fancy}
\lhead{\space \qquad \space}
\chead{应用层 \qquad}
\rhead{\qquad\thepage/\pageref{LastPage}}
\begin{document}

% \tableofcontents

% \clearpage
\section{应用层协议原理}
	网络应用程序有两个例子，一个是web应用程序，另一个是P2P文件共享系统。\par

	web应用程序中包含着浏览器程序和web服务器程序。浏览器程序运行在用户主机上，web服务器程序运行在web服务器主机上。\par

	P2P文件共享系统在参与文件共享的社区中的每台主机中都有一个程序。

\subsection{网络应用程序体系结构}
	网络应用程序体系结构有两种主流的结构，一个是客户-服务器体系结构，还有一个是对等(P2P)体系结构。\par

\subsubsection{客户-服务器体系结构}
	这个结构有两个特征：
	\begin{itemize}
		\item[1.] 有一个总是打开的主机称为服务器，它服务于来自许多其他称为客户的主机的请求。
		\item[2.] 该服务器具有固定的、周知的地址，该地址成为IP地址。
	\end{itemize}

\subsubsection{P2P体系结构}
	在一个P2P体系结构中，对位于数据中心的专用服务器有最小的依赖。应用程序在间接连接的主机对之间使用直接通信，这些主机对被称为对等方。
	这种对等方通信不必通过专门的服务器。\par

	P2P体系结构具有自扩展性，尽管每个对等方都由于请求文件产生工作量，但每个对等方通过向其他对等方分发文件也为系统增加了服务能力。\par

	P2P体系结构面临着3个主要挑战：
	\begin{itemize}
		\item[1.] ISP友好，P2P应用需要设计对ISP友好的模式。
		\item[2.] 安全性，P2P应用高度分布和开放，所以不安全。
		\item[3.] 激励，只有用户资源自愿向应用提供带宽、存储和计算资源，P2P应用才能成功。
	\end{itemize}

\subsection{进程通信}
	在两个不同端系统上的进程，通过跨越计算机网络交换报文而相互通信。
	发送进程生成并向网络中发送报文，接收进程接收这些报文并可能通过将报文发送回去进行相应。

\subsubsection{客户和服务器进程}
	对每对通信进程，我们通常将这两个进程之一标识为客户，而另一个进程标识为服务器。
	发起通信的进程被标识为客户，在会话开始时等待联系的进程是服务器。

\subsubsection{进程与计算机网络之间的接口}
	从一个进程向另一个进程发送的报文必须通过下面的网络。进程通过一个称为套接字的软件接口向网络发送报文和从网络接收报文。\par

	套接字是同一台主机内应用层与运输层之间的接口，由于该套接字是建立网络应用程序的可编程接口，因此套接字也称为应用程序和网络之间的应用程序编程接口。

\subsubsection{进程寻址}
	在一台主机上的进程为了向在另一台主机上运行的进程发送分组，接收进程需要有一个地址。
	为了标识该接收进程，需要定义两种信息：1.主机的地址；2.定义在目的主机中的接收进程的标识符。\par

	在因特网中，主机地址由IP地址标识。\par

	目的地端口号用于定义在目的主机中的接收进程，比如说Web服务器用端口号80来标识。

\subsection{可供应用程序使用的运输服务}
	一个运输层协议必须为它的应用程序提供四种服务：可靠数据传输、吞吐量、定时和安全性。

\subsubsection{可靠数据传输}
	运输层确保由应用程序的一端发送的数据正确、完全地交付给该应用程序的另一端。
	如果应用层协议提供了这样的确保数据交付服务，就认为提供了可靠数据传输。

\subsubsection{吞吐量}
	可用吞吐量就是发送进程能够向接收进程交付比特的速率。运输层协议能够以某种特定的速率提供确保的可用吞吐量。

\subsubsection{定时}
	运输层协议能够提供定时保证，比如发送方注入进套接字中的每个比特到达接收方的套接字不迟于100ms。

\subsubsection{安全性}
	运输层协议能够为应用程序提供一种或多种安全性服务。
	比如，在发送主机中，运输协议能够加密由发送进程传输的所有数据，在接收主机中，运输层协议能够在数据交付给接收进城之前解密这些数据。

\subsection{因特网提供的运输服务}
	因特网为应用程序提供两个运输层协议，即UDP和TCP。

\subsubsection{TCP服务}
	当应用程序调用TCP作为其运输协议时，TCP将提供两种服务：
	\begin{itemize}
		\item[1.] 面向连接的服务：在应用层数据报文开始流动之前，TCP让客户和服务器经历一个握手过程，互相交换运输层控制信息。在握手过程之后，一个TCP连接就在两个进程的套接字之间建立了。
		\item[2.] 可靠的数据传送服务：通信进程能够依靠TCP，无差错、按适当顺序交付所有发送的数据。
	\end{itemize}

	TCP还有拥塞控制机制，当发送方和接收方之间的网络出现拥塞时，TCP的拥塞控制机制会抑制发送进程。

\subsubsection{UDP服务}
	UDP服务没有握手过程，也没有UDP连接，没有拥塞控制机制，仅提供最小服务。\par

	当进程将一个报文发送进UDP套接字时，UDP协议并不保证该报文将到达接收进程，而且到达接收进程的报文也可能是乱序到达的。

\subsection{应用层协议}
	应用层协议定义了运行在不同端系统上的应用程序进程如何相互传递报文。应用层协议定义了如下内容：
	\begin{itemize}
		\item[1.] 交换的报文类型，例如请求报文和响应报文。
		\item[2.] 各种报文类型的语法，如报文中的各个字段及这些字段是如何描述的。
		\item[3.] 字段的语义，即这些字段中包含的信息的含义。
		\item[4.] 一个进程何时以及如何发送报文，对报文进行响应的规则。
	\end{itemize}

\section{Web和HTTP}
\subsection{HTTP概况}
	Web应用的应用层协议是HTTP，也就是超文本传输协议。\par

	web客户程序和web服务器程序运行在不同的端系统中，通过交换HTTP报文进行会话。
	HTTP定义了这些报文的结构以及客户和服务器进行报文交换的方式。

\subsubsection{一些web术语}
	一个Web页面是由对象组成的，一个对象就是一个文件，通过URL地址寻址得到。\par

	每个URL地址由两部分组成：存放对象的服务器主机名和对象的路径名。
	比如，URL地址为http://www.someSchool.edu/someDepartment/picture.gif，其中www.someSchool.edu是主机名，/someDepartment/picture.gif是路径名。\par

	web浏览器实现了HTTP的客户端，web服务器实现了HTTP的服务器端，它用于存储web对象，每个对象由URL寻址。

\subsubsection{HTTP的作用}
	HTTP定义了web客户向web服务器请求web页面的方式，以及服务器向客户传送web页面的方式。\par

	HTTP使用TCP作为它的支撑运输协议，HTTP客户首先发起一个与服务器的TCP连接，一旦连接建立，该浏览器和服务器进程就可以通过套接字接口访问TCP。
	客户向它的套接字接口发送HTTP请求报文并从它的套接字接口接收HTTP响应报文，服务器从它的套接字接口接收HTTP请求报文并从它的套接字接口发送HTTP响应报文。

\subsubsection{无状态协议}
	HTTP服务器向客户发送被请求的文件，而不存储任何关于该客户的状态信息，所以我们说HTTP是一个无状态协议。\par

	假如某个特定的客户在短短的几秒钟内两次请求同一个对象，服务器并不会因为刚刚为该客户提供了该对象就不再做出反应，而是重新发送该对象，就像服务器已经完全忘记不久之前所做过的事一样。

\subsection{请求html文件的时间}
	在这里将估算一下从客户请求HTML基本文件起到该客户收到整个文件止所花费的时间。\par

	首先定义往返时间RTT：一个短分组从客户机到服务器然后再返回客户所花费的时间。
	RTT包括分组传输时延、分组在中间路由器和交换机上的排队时延以及分组处理时延。\par

	HTTP客户向HTTP请求HTML文件时，需要发起TCP连接，然后请求文件，最后服务器发送HTML文件。发起TCP连接和请求文件各占一个RTT时间，
	所以总的时间为两个RTT加上服务器传输HTML文件的时间。

\subsection{非持续连接和持续连接}
	在客户和服务器相互通信的过程中，客户发出一系列请求并且服务器对每个请求进行响应。
	对于非持续连接的HTTP，每个请求-响应对经过一个单独的TCP连接发送。
	而对于持续连接的HTTP，所有请求-响应对都经过相同的TCP连接发送。

\subsubsection{非持续连接的HTTP}
	HTTP客户向HTTP服务器请求一个web页面，该web页面包含一个html文件和10个jpeg图形，该html文件的url为：http://www.someSchool.edu/someDepartment/home.index。
	步骤如下：
	\begin{itemize}
		\item[1.] HTTP客户进程在端口号80发起一个到服务器www.someSchool.edu的TCP连接，随后在客户和服务器上分别有一个套接字与该连接相关联。
		\item[2.] HTTP客户经它的套接字向服务器发送一个HTTP请求报文，其中包含html文件的路径/someDepartment/home.index。
		\item[3.] HTTP服务器进程经它的套接字接收该请求报文，根据路径名得到html文件。在一个http响应报文中封装对象，并通过套接字向客户发送响应报文。
		\item[4.] HTTP服务器进程通知TCP断开该TCP连接。
		\item[5.] HTTP客户接收响应报文，TCP连接关闭。客户从响应报文中提取出该文件，检查该html文件，得到对10个jpeg图形的引用。
		\item[6.] 对每个引用的jpeg图形对象重复前4个步骤。
	\end{itemize}

	非持续连接的缺点为：
	\begin{itemize}
		\item[1.] 必须为每一个请求的对象建立和维护一个全新的连接。
		\item[2.] 每一个对象经受两倍RTT的交付时延，即一个RTT用于创建TCP，另一个RTT用于请求和接收一个对象。
	\end{itemize}

\subsubsection{持续连接的HTTP}
	在采用持续连接的情况下，服务器在发送响应后保持该TCP连接打开。
	在相同的客户与服务器之间的后续请求和响应报文能够通过相同的TCP连接进行传送。

\subsection{HTTP报文格式}
	HTTP报文有两种：请求报文和响应报文。

\subsubsection{HTTP请求报文}
	一个典型的HTTP请求报文：
	\begin{lstlisting}
	GET /somedir/page.html HTTP/1.1\r\n
	Host: www.someschool.edu\r\n
	Connection: close\r\n
	User-agent: Mozilla/5.0\r\n
	Accept-language: fr\r\n
	\r\n
	\end{lstlisting}

	HTTP请求报文的第一行叫做请求行，后继的行叫做首部行：
	\begin{itemize}
		\item 请求行有3个字段：方法字段、URL字段和HTTP版本字段。方法字段有：GET、POST、HEAD、PUT和DELETE。
		\item 首部行中，Host用于指定对象所在的主机，Connection用于指定这条连接在请求响应结束后是否关闭，User-agent用于指定浏览器的类型，Accept-language用于指定对象的哪个语言版本。
	\end{itemize}

	各个方法：
	\begin{itemize}
		\item POST，将使用一个“entity body”。使用POST报文时，用户可以向服务器请求一个web页面，这个web页面的特定内容依赖于用户在表单字段中输入的内容。entity body中包含的就是用户在表单字段中的输入值。
		\item GET，此时entity body为空。不过HTML表单也经常使用GET方法，它会在所请求的URL中包含输入的数据。
		\item HEAD，类似于GET方法。当服务器收到使用HEAD方法的请求时，将会用一个HTTP报文进行响应，但是并不返回请求对象。
		\item PUT，允许用户上传对象到指定的web服务器上指定的路径。
		\item DELETE，允许用户或者应用程序删除web服务器上的对象。
	\end{itemize}

\subsubsection{HTTP响应报文}
	一个典型的HTTP响应报文：
	\begin{lstlisting}
	HTTP/1.1 200 OK\r\n
	Connection: close\r\n
	Data: Tue, 09 Aug 2011 15:44:04 GMT\r\n
	Server: Apache/2.2.3(CentOS)\r\n
	Last-Modified: Tue, 09 Aug 2011 15:11:03 GMT\r\n
	Content-length: 6821\r\n
	Content-Type: text/html\r\n
	\r\n
	(data data data data data ...)
	\end{lstlisting}

	响应报文的第一行为状态行，还有6个首部行，最后是entity body：
	\begin{itemize}
		\item 状态行，包含协议版本字段、状态码和相应状态信息。
		\item 首部行中，Connection：close告诉客户发送完报文后关闭该TCP连接，Data用于指示服务器产生并发送该响应报文的日期和时间。
			  Server用于指定服务器类型，Last-Modified用于指定对象创建或最后修改的日期和时间，Content-Length用于指定发送对象的字节数，
			  Content-Type：用于指定entity body中的对象类型。
	\end{itemize}

	一些常见的状态码和相应状态信息：
	\begin{itemize}
		\item 200 OK：请求成功。
		\item 301 Moved Permanently：请求的对象已经被永久转移了。新的URL定义在响应报文的Location中。
		\item 400 Bad Request：一个通用差错代码。
		\item 404 Not Found：被请求的文档不在服务器上。
		\item 505 HTTP Version Not Supported：服务器不支持请求报文使用的HTTP协议版本。
	\end{itemize}

\subsection{用户与服务器的交互}
	cookie技术有4个组件：
	\begin{itemize}
		\item HTTP响应报文中的一个Set-cookie首部行。
		\item HTTP请求报文中的一个Cookie首部行。
		\item 在用户端系统中保留有一个cookie文件，并由用户的浏览器进行管理。
		\item 在服务器端有一个后端数据库。
	\end{itemize}

	课本的第72～73页有一个生动的例子。

\subsection{Web缓存器}
	Web缓存器也叫代理服务器，它是能够代表初始化Web服务器来满足HTTP请求的网络实体。\par

	Web缓存器有自己的磁盘存储空间，并在存储空间中保存最近请求过的对象的副本。
	可以配置浏览器，使得HTTP请求首先指向web缓存器。如果web缓存器没有该对象，web缓存器会向初始服务器请求对象，然后存储一份副本，并向客户发送该副本。\par

	Web缓存器的优点：
	\begin{itemize}
		\item web缓存器可以大大减少对客户请求的响应时间。
		\item web缓存器能够大大减少一个机构的接入链路到因特网的通信量。通过减少通信量，该机构就不必急于增加带宽，因此降低了费用。
	\end{itemize}

	课本的第75页通过一个例子介绍了web缓存器的优点。

\subsection{条件GET方法}
	条件GET方法可以让缓存器证实它的对象是最新的，条件GET方法要求：
	\begin{itemize}
		\item 请求报文使用GET方法。
		\item 请求报文中包含一个“If-Modified-Since”的首部行。
	\end{itemize}

	课本的第76～77页有一个例子介绍了这个方法的使用。

\section{文件传输协议：FTP}
	FTP的步骤如下：
	\begin{itemize}
		\item[1.] 用户首先提供远程主机的主机名，使本地主机的FTP客户进程建立一个到远程主机的FTP服务器进程的TCP连接。
		\item[2.] 该用户接着提供用户标识和口令，作为FTP命令的一部分在该TCP连接上传送。
		\item[3.] 一旦该服务器向该用户授权，用户可以将存放在本地文件系统中的一个或者多个文件复制到远程文件系统。
	\end{itemize}

	FTP使用了两个并行的TCP连接：
	\begin{itemize}
		\item 控制连接，用于在两主机之间传输控制信息。
		\item 数据连接，用于实际发送一个文件。
	\end{itemize}

	因为FTP使用一个独立的控制连接，所以FTP的控制信息是带外的。而HTTP协议在同一个TCP连接中发送请求和响应首部行，所以是带内的。\par

	FTP服务器必须在整个会话期间保留用户的状态，也就是对每个进行中的用户会话的状态信息进行追踪。

\subsection{FTP命令和回答}
	一些较为常见的命令如下：
	\begin{itemize}
		\item USER username，用于向服务器传送用户标识。
		\item PASS password，用于向服务器发送用户口令。
		\item LIST，用于请求服务器回送当前远程目录中的所有文件列表。
		\item RETR filename，用于从远程主机当前目录获取文件。
		\item STOR filename，用于在远程主机的当前目录存放文件。
	\end{itemize}

	一些典型的回答如下：
	\begin{itemize}
		\item 331 Username OK, Password required
		\item 125 Data connection already open; transfer starting
		\item 425 Can't open data connection
		\item 452 Error writing file
	\end{itemize}

\section{因特网中的电子邮件}
	因特网电子邮件系统的3个主要组成部分：用户代理、邮件服务器和简单邮件传输协议。\par

	一个典型的邮件发送过程是：从发送方的用户代理开始，传输到发送方的邮件服务器，在传输到接收方的邮件服务器，然后在这里被分发到接收方的邮箱中。

\subsection{简单邮件传输协议SMTP}
	SMTP用于从发送方的邮件服务器发送报文到接收方的邮件服务器。\par

	邮件服务器的端口号是25。\par

	SMTP的工作过程：SMTP客户端发现发送方邮件服务器中报文队列中的这个报文，然后创建一个到接收方邮件服务器上的SMTP服务器的TCP连接。经过一些初始SMTP握手后，SMTP客户通过该TCP连接发送报文。
	在接收方邮件服务器上，SMTP的服务器端接收该报文。在握手阶段，SMTP客户端会指示发送方的邮件地址和接收方的邮件地址。\par

	SMTP不使用中间邮件服务器发送邮件。\par

	SMTP有一些常用的命令：HELO、MAIL FROM、RCPT TO、DATA以及QUIT。在课本的第82页有一个SMTP工作的例子。\par

	对于每个报文，客户通过MAIL FROM开始，用一个独立的句点“.”指示该邮件的结束，并且仅当所有邮件发送完后才发送QUIT。

\subsection{邮件报文格式}
	一个邮件报文由首部、空行和报文体组成。\par

	每个首部必须含有一个From，一个To，有时候还可能包含一个Subject。一个典型的报文首部如下：
	\begin{lstlisting}
	From: alice@crepes.fr
	To: bob@hamburger.edu
	Subject: Searching for the meaning of life
	\end{lstlisting}

\subsection{邮件访问协议}
	我们通过邮局访问协议将邮件服务器上的报文传送回本地PC。流行的邮件访问协议有：第三版的邮局协议POP3、因特网邮件访问协议IMAP以及HTTP。

\subsubsection{POP3}
	POP3按照三个阶段进行工作：
	\begin{itemize}
		\item 特许阶段，用户代理发送用户名和口令来鉴别用户。
		\item 事务处理阶段，用户代理取回报文，同时用户代理还能对报文做删除标记、取消报文删除标记，以及获取邮件的统计信息。
		\item 更新阶段，在客户发出quit命令后开始，目的是结束该POP3会话。此时，邮件服务器删除那些被标记为删除的报文。
	\end{itemize}

	服务器对用户代理的命令有两种：
	\begin{itemize}
		\item +OK，指示命令正常。
		\item -ERR，指示命令出现了某些差错。
	\end{itemize}

	特许阶段有两个命令：user <username>和pass <password>，例子如下：
	\begin{lstlisting}
	telnet mailServer 110
	user bob
	pass hungry
	\end{lstlisting}

	事务处理阶段有四个命令：list、retr、dele和quit。

\subsubsection{IMAP}
	IMAP的两个重要特性：
	\begin{itemize}
		\item[1.] IMAP服务器把每个报文与一个文件夹联系起来，并且维护了IMAP会话的用户状态信息。
		\item[2.] IMAP允许用户代理获取报文组件的命令，也就是说，一个用户代理可以只读区一个报文的报文首部，或只是一个多部分MIME报文的一部分。
	\end{itemize}

\section{DNS:因特网的目录服务}
\subsection{DNS提供的服务}
	识别主机有两种方式：通过主机名或者IP地址。\par

	域名系统DNS的作用：进行主机名到IP地址转换的目录服务。\par

	DNS的组成：
	\begin{itemize}
		\item[1.] 一个由分层的DNS服务器实现的分布式数据库。
		\item[2.] 一个使得主机能够查询分布式数据库的应用层协议。
	\end{itemize}

	DNS协议运行在UDP上，使用53号端口。\par

	课本第88页上有一个DNS服务的例子。\par

	DNS提供的服务：
	\begin{itemize}
		\item 主机别名，有着复杂主机名的主机能拥有一个或者多个别名。
		\item 邮件服务器别名。电子邮件应用程序可以调用DNS，对提供的邮件服务器别名进行解析，以获得该主机的规范主机名及其IP地址。
		\item 负载分配，一个IP地址集合与同一个规范主机名相联系。
	\end{itemize}

\subsection{DNS工作机理概述}
\subsubsection{集中式DNS服务器}
	集中式DNS服务器的缺点：
	\begin{itemize}
		\item 单点故障
		\item 通信容量
		\item 远距离的集中式数据库
		\item 维护
	\end{itemize}

\subsubsection{分布式、层次DNS服务器}
	域名DNS采用分布式、层次数据库，分为三层：
	\begin{itemize}
		\item[1.] 第一层是根DNS服务器，用于返回顶级域名DNS服务器的IP地址。
		\item[2.] 第二层是顶级域DNS服务器，负责com、org、net等顶级域名，用于返回相应权威DNS服务器的IP地址。
		\item[3.] 第三层是权威DNS服务器，用于返回一个组织机构的IP地址。
	\end{itemize}

	书本第91页有分布式、层次数据库工作的例子。

\subsubsection{本地DNS服务器}
	当主机发出DNS请求时，这个请求是发往本地DNS服务器，本地DNS服务器起着代理的作用，
	并将请求转发到DNS服务器层次结构中，获得相应IP地址后，再返回给主机。\par

	书本第92页有使用本地DNS服务器的例子。

\subsubsection{DNS缓存}
	在一个请求链中，当某DNS服务器接收一个DNS回答时，它能将该回答中的信息缓存在本地存储器中，这就是DNS缓存。\par

	DNS服务器在一段时间后将丢弃缓存的信息。

\subsection{DNS记录和报文}
\subsubsection{DNS资源记录}
	DNS服务器中存储了资源记录，用于提供主机名到IP地址的映射。\par

	资源记录的数据结构是一个4元组：(Name, Value, Type, TTL)：
	\begin{itemize}
		\item TTL是这条记录的生存时间，决定了资源记录应当从缓存中删除的时间。
		\item Name和Value取决于Type的值：
		\begin{itemize}
			\item 如果Type=A，则Name是主机名，Value是该主机名对应的IP地址。
			\item 如果Type=NS，则Name是一个域名，Value是一个知道如何获得该域中主机IP地址的权威DNS服务器的主机名。
			\item 如果Type=CNAME，则Name是一个主机别名，Value是一个规范主机名。
			\item 如果Type=MX，则Name是一个邮件服务器别名，Value是一个邮件服务器的规范主机名。
		\end{itemize}
	\end{itemize}

\subsubsection{DNS报文}
	DNS有两种报文：DNS查询报文和DNS回答报文。\par

	DNS报文格式如下：
	\begin{itemize}
		\item 前12个字节是首部区域，有6个字段：
		\begin{itemize}
			\item 标识符，用于标识该查询。
			\item 标志字段，含有若干标志：“查询／回答”标志位、“希望递归”标志位等。
			\item 其他4个有关数量的字段：问题数、回答RR数、权威RR数和附加RR数。这些字段指出了在首部后的4类数据区域出现的数量。
		\end{itemize}

		\item 问题区域，包含：名字字段，指出正在被查询的主机名字；类型字段，也就是资源记录中的Type值。

		\item 回答区域，包含了对最初请求的名字的资源记录。

		\item 权威区域，包含了其他权威服务器的记录。

		\item 附加区域，包含了其他有帮助的记录。
	\end{itemize}

\subsection{在DNS数据库中插入记录}
	注册域名机构用于将域名输入DNS数据库，也就是在DNS数据库中插入记录。\par

	当某个机构向注册域名机构注册域名时，需要提供基本和辅助权威DNS服务器的主机名和IP地址。
	随后注册登记机构将一个类型NS和一个类型A的记录输入相应的所有的TLD顶级域名DNS服务器中。

\section{P2P应用}
	P2P体系结构对总是打开的基础设施服务器有着最小的依赖。\par

	有两种特别适合于P2P设计的应用：
	\begin{itemize}
		\item 文件分发，其中应用程序从单个源向大量的对等方分发一个文件。
		\item 分布在大型对等方社区中的数据库。
	\end{itemize}

\subsection{P2P文件分发}
\subsubsection{BitTorrent}
	BitTorrent是一种用于文件分发的流行P2P协议。\par

	洪流torrent：参与一个特定文件分发的所有对等方的集合。\par

	追踪器：当一个对等方加入某洪流时，它向追踪器注册自己，并周期性地通知追踪器它仍在该洪流中，追踪器跟踪正参与在洪流中的对等方。\par

	稀缺优先技术：针对一个主机没有的块，在它的邻居中决定最稀缺的块，并首先请求那些最稀缺的块。
	最稀缺的块就是那些在它的邻居中副本数量最少的块。\par

	BitTorrent中的对换算法(一报还一报)：一台主机有接收比特速率前4个对等方和一个试探的对等方。前4个对等方称为疏通，
	该主机每10秒重新计算一次接收比特速率并修改这4个对等方的集合。
	该主机每过30秒随机选择一名新的对换伴侣并开始与对方进行对换，如果双方接收速率都排前4，
	它们将对方放入前4位列表中并继续与对方进行兑换，直到双方中的一个发现了一个更好的伴侣为止。
	需要知道的是，除了上述的5个对等方，其他的邻居都不能从这台主机接收到任何块。\par

	课本第101页有BitTorrent的工作流程的例子。

\subsection{分布式散列表}
	分布式散列表：一个分布式数据库，该数据库只包含键值对，它在数以百万计的对等方上存储键值对，
	每个对等方将保持键值对仅占总体的一个小子集。当查询分布式数据库时，它将定位拥有相应的键值对的对等方，然后向查询的对等方返回该键值对。\par

	课本第103页上有DHT数据库应用的一个例子。\par

	构建DHT的一种幼稚的方法：
	\begin{itemize}
		\item[1.] 首先让每个对等方维护一个所有对等方的列表。
		\item[2.] 然后向所有的对等方随机地散布键值对。
		\item[3.] 实际查询时，查询的对等方向所有其他对等方发送它的查询，并且包含相应键值对的对等方能对其作出反应。
	\end{itemize}

	设计DHT的一种精确有效的方法：首先为对等方分配键值对：给定每个对等方一个整数标识符，每个键也是一个位于相同范围的整数。
	分配键值对的原则：为最邻近一个键的对等方分配一个键值对。\par

	最邻近的定义：如果键小于标识符，就采取最邻近后继；如果键等于多个标识符，就在匹配的对等方中存储键值对；如果键大于所有标识符，
	对所有标识符进行模$2^n$，在具有最小标识符的对等方中存储键值对。\par

	确定一个键的最近邻对等方的方法：
	\begin{itemize}
		\item[1.] 环形DHT
		\item[2.] 对等方扰动
	\end{itemize}

\subsubsection{环形DHT}
	环形DHT中每个对等方仅与它的直接后继和直接前任联系。这种情况下，为了找到相应键值对的对等方，平均需要发送N/2条报文。\par

	而如果每个对等方都关联了其他所有对等方，那么每次查询仅需要发送一个报文。\par

	研究表明DHT能被设计成每个对等方的邻居数量以及每个请求的报文数量均为$O(\log N)$。

\subsubsection{对等方扰动}
	对等方扰动：对等方不加警示地到来和离去。\par

	为处理对等方扰动，我们要求每个对等方联系其第一个和第二个候机，并周期性地证实它的两个后继是存活的。\par

	在课本的第105页有处理对等方突然离去的例子，课本的第106页有新的对等方加入DHT的例子。

\end{document}
