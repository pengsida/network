% !TeX spellcheck = en_US
%% 字体：方正静蕾简体
%%		 方正粗宋
\documentclass[a4paper,left=2.5cm,right=2.5cm,11pt]{article}

\usepackage[utf8]{inputenc}
\usepackage{fontspec}
\usepackage{cite}
\usepackage{xeCJK}
\usepackage{indentfirst}
\usepackage{titlesec}
\usepackage{longtable}
\usepackage{graphicx}
\usepackage{float}
\usepackage{rotating}
\usepackage{subfigure}
\usepackage{tabu}
\usepackage{amsmath}
\usepackage{setspace}
\usepackage{amsfonts}
\usepackage{appendix}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry}
\setcounter{secnumdepth}{4}
\usepackage{mhchem}
\usepackage{multirow}
\usepackage{extarrows}
\usepackage{hyperref}
\titleformat*{\section}{\LARGE}
\renewcommand\refname{参考文献}
\renewcommand{\abstractname}{\sihao \cjkfzcs 摘{  }要}
%\titleformat{\chapter}{\centering\bfseries\huge\wryh}{}{0.7em}{}{}
%\titleformat{\section}{\LARGE\bf}{\thesection}{1em}{}{}
\titleformat{\subsection}{\Large\bfseries}{\thesubsection}{1em}{}{}
\titleformat{\subsubsection}{\large\bfseries}{\thesubsubsection}{1em}{}{}
\renewcommand{\contentsname}{{\cjkfzcs \centerline{目{  } 录}}}
\setCJKfamilyfont{cjkhwxk}{STXingkai}
\setCJKfamilyfont{cjkfzcs}{STSongti-SC-Regular}
% \setCJKfamilyfont{cjkhwxk}{华文行楷}
% \setCJKfamilyfont{cjkfzcs}{方正粗宋简体}
\newcommand*{\cjkfzcs}{\CJKfamily{cjkfzcs}}
\newcommand*{\cjkhwxk}{\CJKfamily{cjkhwxk}}
\newfontfamily\wryh{Microsoft YaHei}
\newfontfamily\hwzs{STZhongsong}
\newfontfamily\hwst{STSong}
\newfontfamily\hwfs{STFangsong}
\newfontfamily\jljt{MicrosoftYaHei}
\newfontfamily\hwxk{STXingkai}
% \newfontfamily\hwzs{华文中宋}
% \newfontfamily\hwst{华文宋体}
% \newfontfamily\hwfs{华文仿宋}
% \newfontfamily\jljt{方正静蕾简体}
% \newfontfamily\hwxk{华文行楷}
\newcommand{\verylarge}{\fontsize{60pt}{\baselineskip}\selectfont}  
\newcommand{\chuhao}{\fontsize{44.9pt}{\baselineskip}\selectfont}  
\newcommand{\xiaochu}{\fontsize{38.5pt}{\baselineskip}\selectfont}  
\newcommand{\yihao}{\fontsize{27.8pt}{\baselineskip}\selectfont}  
\newcommand{\xiaoyi}{\fontsize{25.7pt}{\baselineskip}\selectfont}  
\newcommand{\erhao}{\fontsize{23.5pt}{\baselineskip}\selectfont}  
\newcommand{\xiaoerhao}{\fontsize{19.3pt}{\baselineskip}\selectfont} 
\newcommand{\sihao}{\fontsize{14pt}{\baselineskip}\selectfont}      % 字号设置  
\newcommand{\xiaosihao}{\fontsize{12pt}{\baselineskip}\selectfont}  % 字号设置  
\newcommand{\wuhao}{\fontsize{10.5pt}{\baselineskip}\selectfont}    % 字号设置  
\newcommand{\xiaowuhao}{\fontsize{9pt}{\baselineskip}\selectfont}   % 字号设置  
\newcommand{\liuhao}{\fontsize{7.875pt}{\baselineskip}\selectfont}  % 字号设置  
\newcommand{\qihao}{\fontsize{5.25pt}{\baselineskip}\selectfont}    % 字号设置 

\usepackage{diagbox}
\usepackage{multirow}
\boldmath
\XeTeXlinebreaklocale "zh"
\XeTeXlinebreakskip = 0pt plus 1pt minus 0.1pt
\definecolor{cred}{rgb}{0.8,0.8,0.8}
\definecolor{cgreen}{rgb}{0,0.3,0}
\definecolor{cpurple}{rgb}{0.5,0,0.35}
\definecolor{cdocblue}{rgb}{0,0,0.3}
\definecolor{cdark}{rgb}{0.95,1.0,1.0}
\lstset{
	language=bash,
	numbers=left,
	numberstyle=\tiny\color{black},
	showspaces=false,
	showstringspaces=false,
	basicstyle=\scriptsize,
	keywordstyle=\color{purple},
	commentstyle=\itshape\color{cgreen},
	stringstyle=\color{blue},
	frame=lines,
	% escapeinside=``,
	extendedchars=true, 
	xleftmargin=1em,
	xrightmargin=1em, 
	backgroundcolor=\color{cred},
	aboveskip=1em,
	breaklines=true,
	tabsize=4
} 

\newfontfamily{\consolas}{Consolas}
\newfontfamily{\monaco}{Monaco}
\setmonofont[Mapping={}]{Consolas}	%英文引号之类的正常显示，相当于设置英文字体
\setsansfont{Consolas} %设置英文字体 Monaco, Consolas,  Fantasque Sans Mono
\setmainfont{Times New Roman}

\setCJKmainfont{华文中宋}


\newcommand{\fic}[1]{\begin{figure}[H]
		\center
		\includegraphics[width=0.8\textwidth]{#1}
	\end{figure}}
	
\newcommand{\sizedfic}[2]{\begin{figure}[H]
		\center
		\includegraphics[width=#1\textwidth]{#2}
	\end{figure}}

\newcommand{\codefile}[1]{\lstinputlisting{#1}}

\newcommand{\interval}{\vspace{0.5em}}

% 改变段间隔
\setlength{\parskip}{0.2em}
\linespread{1.1}

\usepackage{lastpage}
\usepackage{fancyhdr}
\pagestyle{fancy}
\lhead{\space \qquad \space}
\chead{运输层 \qquad}
\rhead{\qquad\thepage/\pageref{LastPage}}
\begin{document}

% \tableofcontents

% \clearpage

\section{概述和运输层服务}
	报文段：在发送端中运输层将从发送应用程序进程接收到的报文转换为运输层分组，这个分组成为报文段。

\subsection{运输层和网络层的关系}
	网络层提供了主机之间的逻辑通信，而运输层为运行在不同主机上的进程之间提供了逻辑通信，运输层刚好位于网络层之上。\par

	运输层提供的服务受制于网络层所能提供的服务。不过即使底层网络协议不能在网络层提供相应的服务，运输层协议也能提供某些服务。
	比如即使底层网络协议是不可靠的，运输层协议也能为应用程序提供可靠的数据传输服务。

\subsection{因特网运输层概述}
	因特网为应用层提供了两种运输层协议：用户数据报协议UDP和传输控制协议TCP。\par

	UDP提供的服务：
	\begin{itemize}
		\item 进程到进程的数据交付。
		\item 进程到进程的数据差错检查。
	\end{itemize}

	TCP提供的服务：
	\begin{itemize}
		\item 进程到进程的数据交付。
		\item 进程到进程的数据差错检查。
		\item 可靠数据传输。
		\item 拥塞控制。
	\end{itemize}

\section{多路复用与多路分解}
	课本第127页有运输层工作的例子。\par

	多路复用：在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息，从而生成报文段，然后将报文段传递到网络层。\par

	多路分解：将运输层报文段中的数据交付到正确的套接字。\par

	运输层多路复用的要求：
	\begin{itemize}
		\item[1.] 套接字有唯一标识符。
		\item[2.] 每个报文段有特殊字段来指示该报文段所要交付到的套接字。这些特殊字段包括源端口号字段和目的端口号字段。
	\end{itemize}

	端口号：一个16比特的数，大小在0～65535之间。其中0～1023的端口号称为周知端口号，用于保留给周知的应用层协议。

\subsection{无连接的多路复用与多路分解}
	一个UDP套接字由一个二元组来标识：(目的IP地址，目的端口号)。\par

	一般来说，运输层自动地为应用程序的客户端分配唯一的端口号，为服务器端分配一个特定的端口号。\par

	课本第129页有UDP复用与分解的例子。

\subsection{面向连接的多路复用与多路分解}
	一个TCP套接字由一个四元组来标识：(源IP地址，源端口号，目的IP地址，目的端口号)。\par

	也就是说，两个具有不同源IP地址或源端口号的到达TCP报文段将被定向到两个不同的套接字。\par

	课本第130页有TCP复用与分解的例子。

\section{无连接运输：UDP}
	UDP的三个特点：
	\begin{itemize}
		\item[1.] UDP从应用程序得到数据，附加上用于多路复用/分解服务的源和目的端口号字段，以及两个其他的小字段，然后将形成的报文段交给网络层。
		\item[2.] 在接收主机上，UDP使用目的端口号将报文段中的数据交付给正确的应用进程。
		\item[3.] 没有拥塞控制。
	\end{itemize}

	称UDP为无连接的原因：在发送报文段之前，发送方和接收方的运输层实体之间没有握手。\par

	DNS是使用UDP的一个例子，见课本第133页。\par

	UDP优于TCP的方面：
	\begin{itemize}
		\item[1.] 关于何时、发送什么数据的应用层控制更为精细。
		\item[2.] 无需建立连接。
		\item[3.] 不需要维护连接状态，可以支持更多的活跃客户。
		\item[4.] 分组首部开销小，UDP的首部只有8字节的开销。
	\end{itemize}

\subsection{UDP报文段结构}
	UDP报文段结构如下：
	\begin{itemize}
		\item 一个首部，有四个字段：
			\begin{itemize}
				\item 源端口号字段和目的端口号字段，UDP通过端口号可以使目的主机将应用数据交给运行在目的端系统中的相应进程。
				\item 长度字段，指示了UDP报文段的字节数。
				\item 检验和，用于检查该报文段是否出现了差错。
			\end{itemize}

		\item 一个数据字段，用于装载应用层数据。
	\end{itemize}

\subsection{UDP检验和}
	检验和的作用：确定当UDP报文段从源到达目的地移动时，其中的比特是否发生了改变。\par

	求检验和的步骤：
	\begin{itemize}
		\item[1.] 对报文段首部中的其他三个字段求和，如果加法有溢出，就将该溢出回卷。
		\item[2.] 将第一步得到的结果求反码，然后存放在UDP报文段中的检验和字段。
	\end{itemize}

	利用检验和进行差错检测的方法：
	\begin{itemize}
		\item[1.] 接收方将报文段首部的4个字段加在一起。
		\item[2.] 检验第一步中得到的结果，如果所有比特全为1，则说明没有出错。
	\end{itemize}

	需要知道的是，UDP只提供了差错检测，但它对差错恢复无能为力。

\section{可靠数据传输原理}
	可靠数据传输的定义：
	\begin{itemize}
		\item[1.] 传输数据比特不会受到损坏或丢失。
		\item[2.] 所有数据都是按照其发送顺序进行交付。
	\end{itemize}

\subsection{构造可靠数据传输协议}
\subsubsection{经完全可靠信道的可靠数据传输：rdt1.0}
	考虑最简单的情况：底层信道是完全可靠的。\par

	课本第138页画出了rdt1.0的有限状态机，需要知道的是，发送方和接收方都有各自的FSM。\par

	在发送端，由较高层应用调用产生rdt\_send(data)事件，然后产生两个动作：
	\begin{itemize}
		\item[1.] 经由make\_pkt(data)动作产生一个包含该数据的分组packet。
		\item[2.] 经由udt\_send(packet)动作将分组发送到信道中。
	\end{itemize}

	在接收端，由较低层协议调用产生rdt\_rcv(packet)动作，然后产生两个动作：
	\begin{itemize}
		\item[1.] 经由extract(packet, data)动作从分组中取出数据。
		\item[2.] 通过deliver\_data(data)动作将数据上传给较高层的应用。
	\end{itemize}

\subsubsection{经具有比特差错信道的可靠数据传输：rdt2.0}
	假设底层信道：
	\begin{itemize}
		\item[1.] 分组中的比特可能受损。
		\item[2.] 所有发送的分组将按其发送的顺序被接收，不会发生丢包。
	\end{itemize}

	自动重传协议(ARQ协议)：使用控制报文“肯定确认(ACK)”和“否定确认(NAK)”。“肯定确认”让发送方知道哪些内容被正确接收，
	“否定确认”让发送方知道哪些内容接收有误并因此需要重复。\par

	ARQ协议中的其他三种协议功能：
	\begin{itemize}
		\item[1.] 差错检测，使得接收方检测到何时出现了比特差错。
		\item[2.] 接收方反馈，让接收方向发送方会送ACK与NAK分组。
		\item[3.] 重传，接收方收到有差错的分组时，发送方将重传该分组文。
	\end{itemize}

	课本第139页画出了rdt2.0的有限状态机。\par

	发送端状态机的描述：
	\begin{itemize}
		\item[1.] 发送端首先处于等待来自上层的调用的状态。
		\item[2.] 上层调用时发生rdt\_send(data)的事件，产生sndpkt=make\_pkt(data, checksum)和udt\_send(sndpkt)的动作，随后进入等待ACK或NAK的状态。
		\item[3.] 处于等待ACK或NAK的状态时，如果发生rdt\_rcv(rcvpkt)\&\&isNAK(rcvpkt)的事件，就产生udt\_send(sendpkt)的动作，并回到等待ACK或NAK的状态。
				  如果发生rdt\_rcv(rcvpkt)\&\&isACK(rcvpkt)的事件，就回到等待来自上层的调用的状态。
	\end{itemize}

	需要知道的是，当发送方处于等待ACK或NAK的状态，它不能从上层获得更多的数据。所以rdt2.0协议又称为停等协议。\par

	接收端状态机的描述：
	\begin{itemize}
		\item[1.] 接收端处于等待来自下层的调用的状态。
		\item[2.] 如果发生rdt\_rcv(rcvpkt)\&\&corrupt(rcvpkt)事件，说明收到的分组受损，然后产生sndpkt=make\_pkt(NAK)和udt\_send(sndpkt)的动作。
				  如果发生rdt\_rcv(rcvpkt)\&\&notcorrupt(rcvpkt)事件，说明收到的分组没有受损，然后产生extract(rcvpkt, data)
				  ，deliver\_data(data)，sndpkt=make\_pkt(ACK)和udt\_send(sndpkt)的动作。
	\end{itemize}

	rdt2.0的缺陷：没有考虑到ACK或NAK分组受损的可能性。如果一个ACK或NAK分组受损，发送方无法知道接收方是否正确接收了上一块发送的数据。\par
	解决方法：当发送方接收到含糊不清的ACK或NAK分组时，只需要重传当前数据分组即可。
	该方法引入的新问题：信道中出现了冗余分组，接收方不知道它接收到的分组是新分组还是一次重传。\par

	针对新问题的解决方法：在数据字段添加一个新字段，让发送方对其数据分组编号，将发送数据分组的序号放在该字段。
	该字段只需要1比特：0或1。如果接收方接收到的分组序号与上一次接收到的分组序号相同，就说明这是一次重传。
	ACK或NAK分组不需要指明确认的分组序号，因为这里假设不丢失分组，所以它们一定是为响应这一次发送的数据分组而生成的。\par

	课本第141页有rdt2.1发送方的状态图，第142页有rdt2.1接收方的状态图。\par

	rdt2.2通过在ACK分组中加入分组序号，实现了无NAK的可靠数据传输协议。
	如果接收方收到受损的分组时，它发送一个带有上一次数据分组序号的ACK分组。
	发送方接收到同一分组的两个ACK分组时，就知道接收方没有正确接收到跟在被确认两次的分组后面的分组。\par

	课本第142页有rdt2.2发送方的状态图，第143页有rdt2.2接收方的状态图。\par

\subsubsection{经具有比特差错信道的丢包信道的可靠数据传输：rdt3.0}
	协议新关注的两个问题：怎么检测丢包以及发生丢包后该做些什么。\par

	如何检测丢包：发送方等待足够长的时间，如果没有接收到接收方的响应，就默认丢包。\par

	发生丢包后该做些什么：只需要重传该数据分组。\par

	如果没有发生丢包又重传时，信道中将引入冗余数据分组。我们在rdt2.1中已经解决了这个问题。\par

	实现一个基于时间的重传机制：
	\begin{itemize}
		\item[1.] 每次发送一个分组时，就启动一个定时器。
		\item[2.] 响应定时器中断，从而采取适当的动作。
		\item[3.] 终止定时器。
	\end{itemize}

	因为分组序号在0和1之间交替，所以rdt3.0被称为比特交替协议。\par

	课本第144页有rdt3.0发送方的状态图，第145页有rdt3.0的运行举例。\par

	课本第144～146页有rdt协议的效率分析。

\subsection{流水线可靠数据传输协议}
	流水线：不使用停等方式运行，允许发送方发送多个分组而无需等待确认，许多从发送方向接收方输送的分组可以被看成是填充到一条流水线中。\par

	解决流水线的差错恢复的两种基本方法：回退N步和选择重传。

\subsubsection{回退N步}
	回退N步协议：允许发送方发送多个分组而不需等待确认，也受限于在流水线中未确认的分组数不能超过某个最大允许数N。\par

	基序号：最早的未确认分组的序号。下一个序号：下一个待发分组的序号。\par

	课本第148页有GBN发送方的状态图，第149页有GBN接收方的状态图。\par

	GBN发送方需要响应三种类型的事件：
	\begin{itemize}
		\item 上层的调用。首先判断是否超过N，如果窗口未满，则产生一个分组并将其发送，并相应地更新分量。如果窗口已满，发送方只需将数据返回给上层。
		\item 收到一个ACK。采取累积确认的方式，发送方接收到的ACK附带的序号为n，就默认n之前且包括n的分组全部被接收方接收到。
		\item 超时事件。如果出现超时，发送方将重传已发送但未被确认过的分组。接收到一个ACK时，如果仍有已发送但未被确认的分组，则定时器被重新启动。
			  如果没有已发送但未被确认的分组，该定时器被终止。
	\end{itemize}

	GBN接收方需要响应的事件：
	\begin{itemize}
		\item 一个分组n根据正确的序号被接收到，则接收方为分组n发送ACK，并将其数据交付给上层。
		\item 在所有其他情况下，接收方丢弃该分组，并为最近按序接收的分组重新发送ACK。根据这个机制，发送方getacknum(rcvpkt)得到的肯定是最近按序接收的分组序号，这保证了数据的按序交付。
	\end{itemize}

	课本第150页有对GBN运行的举例。\par

	因为GBN协议未确认的分组数不能超过某个最大允许数N，这被视为一个窗口，GBN协议也被称为滑动窗口协议。

\subsubsection{选择重传}
	GBN协议的缺陷：单个分组的差错就能够引起GBN重传大量分组，随着信道差错率的增加，流水线可能会被这些不必要重传的分组所充斥。\par

	选择重传：通过让发送方仅重传那些它怀疑在接受方出错的分组而避免不必要的重传。\par

	SR发送方需要处理的事件：
	\begin{itemize}
		\item 从上层收到数据。如果序号位于发送方的窗口内，则将数据打包并发送。
		\item 超时。现在每个分组必须拥有其自己的逻辑定时器，因为超时发生后职能发送一个分组。
		\item 收到ACK。如果ACK携带的分组序号位于窗口内，则SR发送方将那个被确认的分组标记为已接收。
			  如果该分组的序号等于send\_base，则窗口基序号向前移动到具有最小序号的未确认分组处。
	\end{itemize}

	SR接收方也建立了一个窗口N，用于限制流水线中未完成、未被确认的分组数。
	SR接收方需要处理的事件：
	\begin{itemize}
		\item 收到的分组落在接受方的窗口内，产生一个ACK分组回送给发送方。
			  如果分组以前从未收到过，则缓存该分组。
			  如果分组序号等于rcv\_base，则窗口向前移动到具有最小序号的未缓存分组处。
		\item 收到的分组序号小于rcv\_base，此时必须产生一个ACK分组回送给发送方，这是考虑到了之前传给发送方的ACK可能丢失。
		\item 其他情况，则忽略该分组。
	\end{itemize}

	课本第152页有SR操作的例子。\par

	当分组序号范围有限时，窗口大小选择不当将产生严重的后果。课本第153页有一个相应的例子。
	窗口长度必须小于或等于分组序号空间大小的一半。\par

\subsection{可靠数据传输机制的总结}
	实现可靠数据传输的机制：
	\begin{itemize}
		\item 检验和，用于检测在一个分组中的比特错误。
		\item 定时器，用于超时重传一个数据分组，因为一个数据分组或ACK分组可能在信道中丢失了。
			  如果一个分组延时但未丢失，导致过早超时，信道中就会出现冗余数据分组。
		\item 序号，具有相同序号的数据分组可使接收方检测出一个分组的冗余副本。接收分组序号间的空隙还可以使接收方检测出丢失的分组。
		\item 肯定确认ACK，用于告诉接收方一个分组或一组分组已被正确接收到了。
		\item 否定确认NAK，用于告诉发送方某个分组未被正确地接收。
		\item 窗口、流水线，用于提高发送方的利用率。
	\end{itemize}

\subsection{分组重新排序问题}
	当连接发送方和接收方两端的信道是一个网络时，分组重新排序是可能发生的。\par

	分组重新排序的表现：一个具有序号或确认号x的分组的旧副本可能会出现，即使发送方或接收方的窗口中都没有包含x。
	这就相当于信道缓存了分组，并在将来任意时刻自然地释放出这个分组。
	因为序号x可以背重新使用，一旦该分组被释放，将导致错误的发生。\par

	解决方法：确保序号x不被重新使用，知道发送方确信任何先前发送的序号为x的分组都不再在网络中为止。

\section{面向连接的运输：TCP}
\subsection{TCP的基本概念}
	TCP的特点：
	\begin{itemize}
		\item[1.] 提供全双工服务。
		\item[2.] TCP连接是点对点的。
		\item[3.] TCP连接的组成包括：一台主机上的缓存、变量与进程连接的套接字，以及另一台主机上的另一组缓存、变量和雨进程连接的套接字。两台主机间的网络元素没有为该连接提供任何缓存和变量。
	\end{itemize}

	最大传输单元MTU：指的是从源主机到目的主机间所有链路上发送的最大链路层帧长度，典型值为1500字节。\par

	最大报文段长度MSS：需要保证一个TCP报文段加上TCP/IP首部可以适合一个链路层帧。TCP/IP首部长度通常为40字节，所以MSS的典型值为1460字节。

\subsection{TCP报文段结构}
	TCP报文段结构如下：
	\begin{itemize}
		\item 16比特的源端口号和16比特的目的端口号。
		\item 32比特的序号和32比特的确认号，用于实现可靠数据传输服务。TCP对序号的使用是基于字节流而不是基于报文段的，所以一个报文段的序号是该报文段首字节的字节流序号。
			  而确认号是目的主机期望从源主机收到的下一字节的序号。因为TCP只确认字节流中到第一个丢失字节为止的字节，所以TCP提供的是累积确认。课本第159页给出了使用序号和确认号的例子。
		\item 16比特的接收窗口字段，用于流量控制。
		\item 16比特的检验和字段。
		\item 4比特的首部长度字段，单位为字。
		\item 6比特的标志字段：
			\begin{itemize}
				\item ACK比特用于确认字段中的值是有效的。
				\item RST、SYN和FIN用于连接建立和拆除。
				\item PSH比特用于指示接收方应立即将数据上交给上层。
				\item URG比特用于指示报文段里存在着被发送端置为“紧急”的数据。
			\end{itemize}

		\item 16比特的紧急数据指针字段，用于指向紧急数据的最后一个字节。
		\item 可选与长度可变的选项字段。
		\item 数据字段。
	\end{itemize}

	课本第157页画出了TCP报文段结构。

\subsection{往返时间的估计与超时}
	TCP中使用超时重传机制，所以超时间隔必须大于该连接的往返时间。\par

	TCP估计往返时间的方法：在任意时刻，为一个已发送但目前未被确认的报文段估计SampleRTT。TCP仅在某一时刻做一次SampleRTT测量，而且绝不为已被重传的报文段计算SampleRTT。\par

	课本的第161页还讨论了EstimatedRTT和DevRTT这两个概念。TCP的超时间隔计算公式如下：
	\begin{equation}
		TimeoutInterval = EstimatedRTT + 4\times DevRTT
	\end{equation}

\subsection{可靠数据传输}
	TCP发送方对三个事件的响应：
	\begin{itemize}
		\item 上层的调用。TCP从应用程序接收数据，将数据封装在一个报文段中，并把该报文段交给IP。
		\item 超时。TCP将重传具有最小序号的未确认的报文，并重启定时器。需要注意的是，TCP中只有一个定时器。
		\item 接收来自接收方的ACK。ACK携带序号y，发送方记载着最早未被确认的字节的序号SendBase。
			  TCP采用累积确认，所以y确认了序号在y之前且包括y的所有字节都已经收到，并且重启定时器。
	\end{itemize}

	课本第164～165页给出了可靠传输的例子。

\subsubsection{超时间隔加倍}
	如果TCP响应超时事件，那么TimeoutInterval将是先前值的两倍。
	而如果定时器在另两个事件(上层的调用、接收到ACK)中的任意一个启动，TimeoutInterval的值将有EstimatedRTT和DevRTT决定。

\subsubsection{快速重传}
	TCP不使用否认确认，而是使用冗余ACK进行否定确认。当接收方接收到一个比期望序号大的失序报文段，接收方检测出间隔，并发送冗余ACK，指示下一个期待字节的序号。\par

	快速重传：一个收到3个冗余ACK，TCP就执行快速重传，也就是在该报文段的定时器过期之前重传丢失的报文段。

\subsection{流量控制}
	一条TCP连接每一侧的主机都为该连接设置了接收缓存，如果接收方读取数据的速度慢于发送方发送数据的速度，那么该连接的接收缓存可能溢出。\par

	流量控制服务：使得发送方的发送速率与接收方的读取速率相匹配。\par

	实现方法：
	\begin{itemize}
		\item[1.] 接收方定义三个变量，RcvBuffer表示接收缓存的大小，LastByteRead表示从缓存读出的数据流的最后一个字节的编号，LastByteRcvd表示从网络中接收的数据流的最后一个字节的编号。
		\item[2.] 接收方维持一个接收窗口的变量rwnd，使得$rwnd=RcvBuffer-[LastByteRcvd - LastByteRead]$。
		\item[3.] 接收方将当前rwnd值放入发给发送方的报文段中的接收窗口字段中，让发送方知道rwnd的值。
		\item[4.] 发送方定义两个变量，LastByteSent和LastByteAckd，两者之差表示发送到连接中但未被确认的数据量。
			      只要让这个值小于rwnd，就能保证接收缓存不会溢出。
	\end{itemize}

	流量控制的缺陷：当rwnd=0时，将导致发送方不会再发报文给接收方，从而接收方也不会发确认报文给发送方，发送方中的rwnd值得不到更新，发送方就会被阻塞而不能再发送数据。\par

	上述缺陷的解决方法：当rwnd=0时，发送方继续发送只有一个字节数据的报文段，这些报文段将会被接收方接收被返回相应的确认报文。

\subsection{TCP连接管理}
	客户TCP通过如下步骤与服务器TCP建立一条连接：
	\begin{itemize}
		\item[1.] 客户端的TCP向服务器的TCP发送一个特殊的TCP报文段，称为SYN报文段。报文段中SYN比特置为1，序号字段中随机选择一个初始序号client\_isn，数据字段中不包含应用层的数据。
		\item[2.] SYN报文段到达服务器主机后，服务器开始分配TCP缓存和变量，并发送SYNACK报文段。SYNACK报文段中SYN比特置为1，序号字段随机选择一个初始序号server\_isn，数据字段中不包含应用层的数据。
		\item[3.] SYNACK报文段到达客户端主机后，客户开始分配TCP缓存和变量，并发送确认报文。报文中SYN比特为0，确认号为server\_isn+1，数据字段包含应用层的数据。
	\end{itemize}

	连接创建过程称为3次握手，在连接创建之后，每一个报文段中的SYN比特都将被置为0。\par

	课本第171～172页讲了TCP连接拆除的例子。\par

	TCP建立过程还有一种可能：服务器TCP接收到SYN报文段，但是SYN报文段中的端口号或源IP地址与服务器主机上的套接字不匹配，那么主机将向源发送一个重置报文段。
	该报文段中RST比特置为1，用于告诉源主机“我没有那个报文段的套接字，请不要再发送该报文段了”。

\section{拥塞控制原理}
\subsection{拥塞原因与代价}
	首先我们考虑随着主机增加其发送速率并使网络变得拥塞，这时候会发生的情况。

\subsubsection{情况1:两个发送方和一台具有无穷大缓存的路由器}
	最简单的拥塞情况：两台主机都有一条连接，且这两条连接共享源与目的地之间的单跳路由，该路由器拥有无穷大的缓存。\par

	主机A和主机B向路由器提供流量的速率为$\lambda_{in}$字节/秒，它们在一段容量为R的共享式输出链路上传输。\par

	因为A和B共享输出链路，所以它们各自最大的吞吐量为$R/2$。从吞吐量看，运行在总吞吐量为R时，链路被充分利用了。
	但是从时延看，随着主机A的发送速率接近$R/2$，平均时延就会越来越大。\par

	课本上第175页的图3-44描述了这一情况。

\subsubsection{情况2:两个发送方和一台具有有限缓存的路由器}
	基本假设：路由器缓存的容量是有限的，当分组到达一个已满的缓存时会被丢弃。\par

	供给载荷$\lambda^'_{in}$的定义：运输层向网络发送初始数据以及重传数据的速率。\par

	考虑三种情况：
	\begin{itemize}
		\item[1.] 主机A能够以某种方式确定路由器中的缓存是否空闲。\par
				  此时只有当缓存空闲时主机A才发送一个分组，所以不会产生丢包，$\lambda_{in}$与$\lambda^'_{in}$相等。

		\item[2.] 主机A仅当确定一个分组已经丢失时才重传。\par
				  当$\lambda^'_{in}=R/2$时，假设数据被交付给接收方应用程序的速率是$R/3$，也就是说0.5R的数据中，有0.166R的数据是重传数据。\par

				  网络阻塞的代价：发送方必须执行重传以补偿因为缓存溢出而丢失的分组。

		\item[3.] 主机A会提前发生超时并重传分组，也就是重传载队列中被推迟但还未丢失的分组。\par
		          此时路由器将转发重传的初始分组副本，也就做了无用功。
				  假定每个分组被路由器平均转发两次，所以当$\lambda^'_{in}=R/2$时，假设数据被交付给接收方应用程序的速率是$R/4$。\par

				  网络阻塞的代价：发送方在遇到大时延的时候，它所进行的不必要重传会引起路由器利用其链路带宽来转发不必要的分组副本。
	\end{itemize}

\subsubsection{情况3:4个发送方和具有有限缓存的多台路由器及多跳路径}
	基本假设：有4台主机发送分组，每台主机都通过交叠的两条路径传输分组。\par

	现在主机A发送分组到主机C，第一跳路由器为R1，第二跳路由器为R2，A-C连接与D-B连接共享路由器R1，与B-D连接共享路由器R2。\par

	当$\lambda_{in}$较小时，路由器缓存溢出较少，$\lambda_{in}$接近$\lambda^'_{in}$，$\lambda_{in}$的增大会导致$\lambda_{out}$的增大。\par

	当$\lambda_{in}$较大时，分组延时较大，此时，B-D的流量到达R2的速率会比A-C流量的到达速率大得多。
	当主机A的供给载荷无穷大时，分组延时极大，R2的缓存空间也就被B-D连接的分组占满了，A-C连接在R2上的吞吐量趋近于0。\par

	每当有一个分组在第二跳路由器上被丢弃时，第一跳路由器所做的工作就是无用功。
	这里出现了新的网络拥塞的代价：当一个分组一个路由器丢弃了，那么每个上游路由器转发该分组而使用的传输容量就被浪费了。

\subsection{拥塞控制方法}
	我们根据网络层是否为运输层拥塞控制提供了显式帮助来区分拥塞控制方法，有两种主要的拥塞控制方法：
	\begin{itemize}
		\item 端到端拥塞控制。这种方法中，网络层没有为运输层拥塞控制提供显式支持，端系统必须通过对网络行为的观察来推断。
			  比如TCP，它通过3次冗余确认来判断是否出现网络拥塞，并决定是否减小其窗口长度。
		\item 网络辅助的拥塞控制。这种方法中，路由器向发送方提供关于网络中拥塞状态的显式反馈信息。拥塞信息从网络反馈到发送方有两种方式：
			  \begin{itemize}
				  \item 直接网络反馈，也就是由网络路由器向发送方发送一个阻塞分组。
				  \item 经由接收方的网络反馈，路由器标记或更新从发送方流向接收方的分组中的某个字段，用于指示拥塞的产生。
				        如果接收方收到带有该标记的分组，接收方就会向发送方通知网络阻塞的情况。
			  \end{itemize}
	\end{itemize}

\subsection{网络辅助的拥塞控制例子：ATM ABR拥塞控制}
	ATM ABR拥塞控制面向VC状态来处理分组交换。\par
	每台交换机维护着有关源到目的地VC的状态，从而提供了两种功能：
	\begin{itemize}
		\item[1.] 交换机可以跟踪各个发送方的行为，比如跟踪它们的平均传输速率。
		\item[2.] 交换机可以采取特定源的拥塞控制动作，比如向发送方发显式信令，从而减少发送方的速率。
	\end{itemize}

	ABR是一种弹性数据传输服务：
	\begin{itemize}
		\item 当网络轻载时，ABR服务会充分利用空闲的可用带宽。
		\item 当网络拥塞时，ABR服务会将其传输速率抑制为某些预先确定的最小传输速率。
	\end{itemize}

	RM信元：资源管理信元，用于在主机和交换机之间传递与拥塞有关的信息。每32个数据信元中会有一个RM信元。\par

	ABR提供了三种机制用于交换机向接收方发送与拥塞相关的信令信息：
	\begin{itemize}
		\item EFCI比特，每个数据信元都包含1比特的显式转发拥塞指示比特。如果接收方收到的数据信元的EFCI比特都置为1，接收方就会将RM信元中的CI比特置为1，并将该RM信元送回发送方。
		\item CI和NI比特，它们处于RM信元中，分别为拥塞指示比特和无增长比特，被交换机所设置。当轻微拥塞时，NI比特置为1，当严重拥塞时，CI比特置为1。
		\item ER的设置，RM信元包含了两字节的显式速率字段。当发生拥塞时，ER字段将被设置为源至目的地的路径上的所有交换机中的最小可支持速率。
	\end{itemize}

\section{TCP拥塞控制}
	TCP拥塞控制的三个问题：
	\begin{itemize}
		\item 第一，一个TCP发送方如何限制它向其连接发送流量的速率？
		\item 第二，一个TCP发送方如何感知从它到目的地之间的路径上存在拥塞？
		\item 第三，当发送方感知到端到端的拥塞时，采用何种算法来改变其发送速率？
	\end{itemize}

\subsection{如何限制发送流量的速率}
	算法如下：
	\begin{itemize}
		\item[1.] 定义一个拥塞窗口变量cwnd。
		\item[2.] 发送方中的两个变量LastByteSent和LastByteAckd，两者之差表示发送到连接中但未被确认的数据量。
			      保证这个值小于cwnd，就能间接地限制发送方的发送速率。
	\end{itemize}

\subsection{如何感知拥塞}
	丢包事件的定义：要么出现超时，要么收到来自接收方的3个冗余ACK。\par

	当出现过度拥塞时，路由器的缓存会溢出，从而丢弃一个数据报，也就引起了发送方的丢包事件，从而让发送方得到拥塞的指示。

\subsection{采用何种算法来改变其发送速率}
	假设不出现丢包事件，TCP使用确认来增大它的拥塞窗口长度：
	\begin{itemize}
		\item TCP将确认的到达作为一切正常的指示，从而增加拥塞窗口的长度。
		\item 如果确认到达的速率较慢，则拥塞窗口的增长速率也较慢。
	\end{itemize}

	上述算法使得TCP称为自计时的。\par

	TCP设置发送速率的指导性原则：
	\begin{itemize}
		\item 一个丢失的报文意味着拥塞，因此当丢失报文段时就应该降低TCP发送方的速率。
		\item 一个确认报文段到达时，应该增加发送方的速率。
		\item 需要探测拥塞开始出现的速率。ACK到达时不断增加速率直到出现丢包事件，随后发送方减小速率，然后再开始新一轮的带宽探测。
	\end{itemize}

	TCP拥塞控制算法的三个主要部分：慢启动、拥塞避免和快速恢复。\par

\subsubsection{慢启动}
	慢启动的算法如下：
	\begin{itemize}
		\item[1.] cwnd的值初始化为1个MSS，并发送一个报文段。
		\item[2.] 当收到非冗余ACK时，将cwnd的值增加一个MSS，并发送与cwnd相等数量的报文段，如此反复下去。
		\item[3.] 出现超时事件时，将ssthresh设置为cwnd／2，将cwnd的值设为1，重传丢失的报文，并重新开始慢启动。
		\item[4.] 出现3个冗余ACK时，将ssthresh设置为cwnd／2，将cwnd的值设为ssthresh+3*MSS，重传丢失的报文，并进入快速恢复状态。
		\item[5.] $cwnd \ge ssthresh$时，进入拥塞避免状态。
	\end{itemize}

\subsubsection{拥塞避免}
	算法如下：
	\begin{itemize}
		\item[1.] 收到非冗余ACK时，cwnd增加MSS*(MSS/cwnd)个字节，并发送与cwnd相等数量的报文段。
		\item[2.] 当出现超时事件时，将ssthresh设置为cwnd／2，将cwnd的值设为1，重传丢失的报文，并进入慢启动状态。
		\item[3.] 出现3个冗余ACK时，将ssthresh设置为cwnd／2，将cwnd的值设为ssthresh+3*MSS，重传丢失的报文，并进入快速恢复状态。
	\end{itemize}

\subsubsection{快速恢复}
	算法如下：
	\begin{itemize}
		\item[1.] 当收到冗余ACK时，cwnd增加一个MSS字节，发送与cwnd相等数量的报文段，并重新进入快速恢复状态。
		\item[2.] 当收到非冗余ACK时，cwnd的值设为ssthresh，并进入拥塞避免状态。
		\item[3.] 当出现超时事件时，将ssthresh设置为cwnd／2，将cwnd的值设为1，重传丢失的报文，并进入慢启动状态。
	\end{itemize}

\subsubsection{TCP拥塞控制：回顾}
	假设不会发生超时事件，丢包仅由3个冗余ACK引起。\par

	TCP的拥塞控制此时为：每个RTT内发送cwnd/MSS个报文，则每个RTT内cwnd线性增加一个MSS，然后出现3个ACK事件时cwnd减半。\par

	TCP拥塞控制也就称为加性增、乘性减拥塞控制方式，也就是AIMD拥塞控制方式。

\subsection{TCP的吞吐量}
	TCP稳态行为的描述：当速率增长到W/RTT时，网络丢弃来自连接的分组，从而导致发送速率减半。然后每过一个RTT发送速率就增加MSS/RTT，知道速率在此达到W/RTT。\par

	对于这个高度理想化的TCP稳态动态性模型，它的平均吞吐量为$\frac{0.75\times W}{RTT}$。
	

\end{document}
